

# recodes binary variables to factors
# this is needed for imputation happiness
recode_binary = function( var.name,
                          dat ) {

  new.dat = dat

  # levels of variable (0/1 or 2/1)
  levels = sort( unique( dat[[var.name]] )[ !is.na( unique( dat[[var.name]] ) )] )

  ##### Recode 1/2 variable #####

  # if( all( levels == c(1,2) ) ) {
  #   # warn if variable has any values besides the expected 1,2
  #   #if( any( !new.dat[[var.name]] %in% c(1,2, NA) ) ) warning( paste( var.name, " had weird values!", sep="" ) )
  #   new.dat[[var.name]] = recode( new.dat[[var.name]], "1='b.Yes'; 2='a.No'" )
  # }

  if( all( levels == c(0,1) ) ) {
    new.dat[[var.name]] = recode( new.dat[[var.name]], "1='b.Yes'; 0='a.No'" )
  } else {
    # warn if variable has any values besides the expected 0,1
    warning("Variable does not use 0/1 coding scheme. It is not being recoded.")
  }

  print( table(dat[[var.name]], new.dat[[var.name]], useNA = "ifany") )

  return(new.dat)
}


############################# FN: GET BOOT CIs FOR A VECTOR OF ESTIMATES #############################


# list with first entry for b and second entry for t2
# n.ests: how many parameters were estimated?
get_boot_CIs = function(boot.res, type, n.ests) {
  bootCIs = lapply( 1:n.ests, function(x) boot.ci(boot.res, type = type, index = x) )
  
  # list with first entry for b and second entry for t2
  # the middle index "4" on the bootCIs accesses the stats vector
  # the final index chooses the CI lower (4) or upper (5) bound
  bootCIs = lapply( 1:n.ests, function(x) c( bootCIs[[x]][[4]][4],
                                             bootCIs[[x]][[4]][5] ) )
}

################################ FORMAT RESULTS ################################

#' Round with trailing zeroes
#'
#' @param x Value to round
#' @param digits Number of digits to keep
#' @export
#' @examples
my_round = function(x, digits) {
  formatC( round( x, digits ), format='f', digits=digits )
}

#' Format CI as string
#'
#' @param lo Lower limit
#' @param hi Upper limit
#' @param digits Number of digits to keep
#' @export
format_CI = function( lo, hi, digits ) {
  paste( "[", my_round( lo, digits ), ", ", my_round( hi, digits ), "]", sep="" )
}

#' Nicely format p-value
#'
#' @param p The p-value
#' @export
format_pval = function(p) {
  if (p >= 0.01) return( my_round( p, 2 ) )
  if (p < 0.01 & p > 10^-5 ) return( formatC( p, format = "e", digits = 0 ) )
  if ( p < 10^-5 ) return("< 1e-05")
}


################################ META-ANALYSIS ################################

#' Convert Pearsons's r to Fisher's z
#'
#' @param r The correlation
#' @export
r_to_z = Vectorize( function(r) {
  .5 * ( log(1 + r) - log(1 - r) )
}, vectorize.args = "r" )

#' Convert Fisher's z to Pearson's r
#'
#' @param z The Fisher's z
#' @export
z_to_r = Vectorize( function(z) {
  ( exp( 2 * z ) - 1 ) / ( exp( 2 * z ) + 1 )
}, vectorize.args = "z" )

# gives CI for tau from meta-analysis fit in metafor

#' Calculate CI for tau from metafor
#'
#' @param meta Object from metafor
#' @param z.to.r Should we convert from Fisher's z to r?
#' @export
tau_CI = function( meta, z.to.r = FALSE ) {
  t2.lb = meta$tau2 - qnorm(1 - 0.05/2) * meta$se.tau2
  t2.ub = meta$tau2 + qnorm(1 - 0.05/2) * meta$se.tau2

  if ( t2.lb > 0 ) tau.lb = sqrt(t2.lb) else tau.lb = 0
  tau.ub = sqrt(t2.ub)

  if( z.to.r == TRUE ) {
    tau.lb = z_to_r(tau.lb)
    tau.ub = z_to_r(tau.ub)
  }

  if ( tau.lb < 0 ) tau.lb = 0

  return( c(tau.lb, tau.ub))
}




################################ MODELS FOR CORRELATED DATA ################################

#' Calculate Wald p-values for lmer
#'
#' These will agree exactly with confint( , method="Wald" ), unlike
#' lmerTest's too-conservative Satterthwaite approximation.
#' @param .m The merMod object from lmer
#' @export
z_pvals = function( .m ) {
  coefs = data.frame( coef( summary( .m ) ) )
  p = data.frame( 2 * ( 1 - pnorm( abs( coefs$t.value ) ) ) )
  row.names(p) = row.names(coefs)
  return(p)
}




